#!/usr/bin/env bash

# Neovim Session Manager - mimics GNU screen interface
# Usage similar to screen: nvim-session [-S name] [-ls] [-r [name]] [-d name]

set -euo pipefail

# Configuration
VERSION="0.1.0"
USER="${USER:-$(whoami)}"
SESSION_DIR="${XDG_RUNTIME_DIR:-/tmp}/nvim-sessions-${USER}"
SOCKET_PREFIX="nvim-session"
SSH_CONTROL_PREFIX="ssh-control"
CONFIG_DIR="${XDG_CONFIG_HOME:-$HOME/.config}/nvim-screen"

# Colors for output
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
RED='\033[0;31m'
NC='\033[0m' # No Color

# Ensure session directory exists
mkdir -p "$SESSION_DIR"

# Function to get the init script to use
get_init_script() {
    local init_script="$CONFIG_DIR/init.lua"
    if [[ -f "$init_script" ]]; then
        echo "$init_script"
    else
        echo ""
    fi
}

# Function to get SSH control master socket path
get_ssh_control_path() {
    local ssh_host="$1"
    # Sanitize hostname for use in filename
    local safe_host="${ssh_host//[^a-zA-Z0-9._-]/_}"
    echo "$SESSION_DIR/${SSH_CONTROL_PREFIX}-${safe_host}.sock"
}

# Function to encode remote session name
# Format: host:sessionname
encode_remote_session() {
    local ssh_host="$1"
    local session_name="$2"
    echo "${ssh_host}:${session_name}"
}

# Function to parse session name and extract SSH host
# Returns empty string if it's a local session
parse_ssh_host() {
    local full_session_name="$1"
    if [[ "$full_session_name" =~ ^([^:]+):(.+)$ ]]; then
        echo "${BASH_REMATCH[1]}"
    else
        echo ""
    fi
}

# Function to parse session name and extract base session name
# Strips SSH host prefix if present
parse_session_name() {
    local full_session_name="$1"
    if [[ "$full_session_name" =~ ^([^:]+):(.+)$ ]]; then
        echo "${BASH_REMATCH[2]}"
    else
        echo "$full_session_name"
    fi
}

# Function to check if SSH control master is active
check_ssh_control_master() {
    local control_path="$1"
    # Hostname is not actually needed - the socket contains the connection info
    # Using a dummy value since SSH ignores it when using control master
    ssh -O check -S "$control_path" dummy 2>&1 | grep -q "Master running"
    return $?
}

# Function to establish SSH control master
establish_ssh_control_master() {
    local ssh_host="$1"
    local control_path
    control_path=$(get_ssh_control_path "$ssh_host")

    # Check if control master already exists and is working
    if [[ -S "$control_path" ]] && check_ssh_control_master "$control_path"; then
        return 0
    fi

    # Establish new control master in background
    ssh -fNM -S "$control_path" \
        -o ControlPersist=yes \
        -o ServerAliveInterval=60 \
        -o ServerAliveCountMax=3 \
        "$ssh_host" 2>&1

    if [[ $? -ne 0 ]]; then
        echo -e "${RED}Failed to establish SSH connection to $ssh_host${NC}"
        return 1
    fi

    # Verify the control master is working
    sleep 0.5
    if check_ssh_control_master "$control_path"; then
        return 0
    else
        echo -e "${RED}SSH control master established but not responding${NC}"
        return 1
    fi
}

# Function to close SSH control master
close_ssh_control_master() {
    local ssh_host="$1"
    local control_path
    control_path=$(get_ssh_control_path "$ssh_host")

    if [[ -S "$control_path" ]]; then
        # Hostname not needed - socket contains connection info
        ssh -O exit -S "$control_path" dummy &>/dev/null
        rm -f "$control_path"
    fi
}

# Function to execute command via SSH using control master
ssh_exec() {
    local ssh_host="$1"
    shift
    local control_path
    control_path=$(get_ssh_control_path "$ssh_host")

    # Hostname not needed - socket contains connection info
    # But we still accept it as parameter for backwards compatibility
    ssh -S "$control_path" dummy "$@"
}

# Function to check if nvim-screen is installed on remote
check_remote_nvim_screen() {
    local ssh_host="$1"

    if ssh_exec "$ssh_host" "command -v nvim-screen" &>/dev/null; then
        return 0
    else
        return 1
    fi
}

# Function to generate a session name
generate_session_name() {
    local base_name="${PWD##*/}"
    local counter=0
    local session_name="$base_name"

    while [[ -S "$SESSION_DIR/${SOCKET_PREFIX}-${session_name}.sock" ]]; do
        counter=$((counter + 1))
        session_name="${base_name}-${counter}"
    done

    echo "$session_name"
}

# Function to get socket path for a session
get_socket_path() {
    local session_name="$1"
    echo "$SESSION_DIR/${SOCKET_PREFIX}-${session_name}.sock"
}

# Function to check if a socket is healthy
check_socket_health() {
    local socket_path="$1"
    nvim --headless --server "$socket_path" --remote-expr '1+1' &>/dev/null
    return $?
}

# Function to list active sessions
list_sessions() {
    local ssh_host="$1"
    local sessions=()
    local has_sessions=false

    if [[ -n "$ssh_host" ]]; then
        # List remote sessions
        echo "Active Neovim sessions on $ssh_host:"
        echo

        # Execute list command on remote host
        local remote_output
        remote_output=$(ssh_exec "$ssh_host" "nvim-screen -ls" 2>&1)
        echo "$remote_output"
        return
    fi

    # List local sessions
    echo "Active Neovim sessions:"
    echo

    for socket in "$SESSION_DIR"/${SOCKET_PREFIX}-*.sock; do
        if [[ -S "$socket" ]]; then
            has_sessions=true
            local full_session_name="${socket##*/}"
            full_session_name="${full_session_name#${SOCKET_PREFIX}-}"
            full_session_name="${full_session_name%.sock}"

            # Parse session name to check if it's remote
            local remote_host
            remote_host=$(parse_ssh_host "$full_session_name")

            # Check if session is healthy
            if check_socket_health "$socket"; then
                if [[ -n "$remote_host" ]]; then
                    echo -e "  ${GREEN}●${NC} $full_session_name (healthy, remote)"
                else
                    echo -e "  ${GREEN}●${NC} $full_session_name (healthy)"
                fi
            else
                if [[ -n "$remote_host" ]]; then
                    echo -e "  ${YELLOW}○${NC} $full_session_name (unresponsive, remote)"
                else
                    echo -e "  ${YELLOW}○${NC} $full_session_name (unresponsive)"
                fi
            fi
        fi
    done

    if [[ "$has_sessions" == false ]]; then
        echo "  No active sessions"
    fi
    echo
}

# Function to start a new session
start_session() {
    local session_name="$1"
    local ssh_host="$2"
    shift 2
    local nvim_args=("$@")
    local socket_path
    socket_path=$(get_socket_path "$session_name")

    if [[ -S "$socket_path" ]]; then
        echo -e "${YELLOW}Session '$session_name' already exists.${NC}"
        echo "Use '$0 -r $session_name' to attach to it."
        exit 1
    fi

    if [[ -n "$ssh_host" ]]; then
        # Start remote session via SSH
        # Encode session name with SSH host
        local encoded_name
        encoded_name=$(encode_remote_session "$ssh_host" "$session_name")
        local marker_path
        marker_path=$(get_socket_path "$encoded_name")

        # Check if remote session already exists locally
        if [[ -e "$marker_path" ]]; then
            echo -e "${YELLOW}Session '$session_name' on $ssh_host already exists.${NC}"
            echo "Use '$0 -r $encoded_name' to attach to it."
            exit 1
        fi

        # Build nvim args string for remote execution
        local nvim_args_str=""
        if [[ ${#nvim_args[@]} -gt 0 ]]; then
            # Properly quote arguments for remote execution
            printf -v nvim_args_str ' -- %q' "${nvim_args[@]}"
        fi

        echo "Starting remote session '$session_name' on $ssh_host..."

        # Create a local marker file to track this remote session
        touch "$marker_path"

        # Start remote session via SSH with pseudo-terminal
        # This will execute nvim-screen on the remote host and attach to it
        exec ssh -t -S "$(get_ssh_control_path "$ssh_host")" "$ssh_host" \
            "nvim-screen -S '$session_name'$nvim_args_str"
    else
        # Local session - original behavior
        # Get the init script to source
        local init_script
        init_script=$(get_init_script)

        # Start nvim with server listening on socket
        if [[ -n "$init_script" ]]; then
            # Source the init script after nvim's standard initialization
            exec nvim --listen "$socket_path" -S "$init_script" "${nvim_args[@]}"
        else
            # No init script, just start normally
            exec nvim --listen "$socket_path" "${nvim_args[@]}"
        fi
    fi
}

# Function to attach to existing session
attach_session() {
    local session_name="$1"
    local socket_path
    socket_path=$(get_socket_path "$session_name")

    # Check if this is a remote session by parsing the session name
    local ssh_host
    ssh_host=$(parse_ssh_host "$session_name")
    local base_session_name
    base_session_name=$(parse_session_name "$session_name")

    if [[ -n "$ssh_host" ]]; then
        echo "Attaching to remote session '$base_session_name' on $ssh_host..."

        # Establish SSH control master if not already active
        if ! establish_ssh_control_master "$ssh_host"; then
            echo -e "${RED}Failed to establish SSH connection${NC}"
            exit 1
        fi

        # Attach to remote session via SSH with pseudo-terminal
        exec ssh -t -S "$(get_ssh_control_path "$ssh_host")" "$ssh_host" \
            "nvim-screen -r '$base_session_name'"
    fi

    if [[ ! -S "$socket_path" ]]; then
        echo -e "${RED}Error: Session '$session_name' not found.${NC}"
        echo
        list_sessions ""
        exit 1
    fi

    # Attach to existing nvim server
    exec nvim --server "$socket_path" --remote-ui
}

# Function to list channels for debugging
list_channels() {
    local session_name="$1"
    local socket_path
    socket_path=$(get_socket_path "$session_name")

    # Check if this is a remote session by parsing the session name
    local ssh_host
    ssh_host=$(parse_ssh_host "$session_name")
    local base_session_name
    base_session_name=$(parse_session_name "$session_name")

    if [[ -n "$ssh_host" ]]; then
        # For remote session, execute channels command on remote host
        echo "Listing channels for remote session '$base_session_name' on $ssh_host..."

        if ! establish_ssh_control_master "$ssh_host"; then
            echo -e "${RED}Failed to establish SSH connection${NC}"
            exit 1
        fi

        ssh_exec "$ssh_host" "nvim-screen -channels '$base_session_name'"
        return $?
    fi

    if [[ ! -S "$socket_path" ]]; then
        echo -e "${RED}Error: Session '$session_name' not found.${NC}"
        exit 1
    fi

    echo "Listing channels for session: $session_name"
    echo

    # Get channel count
    echo "Number of channels:"
    nvim --headless --server "$socket_path" --remote-expr \
        'luaeval("#vim.api.nvim_list_chans()")' 2>&1

    echo
    echo "Channel details (JSON format):"
    nvim --headless --server "$socket_path" --remote-expr \
        'luaeval("vim.json.encode(vim.api.nvim_list_chans())")' 2>&1 | jq '.' 2>/dev/null || cat

    echo
    echo "Channel summary:"
    nvim --headless --server "$socket_path" --remote-expr \
        'execute("lua for _, c in ipairs(vim.api.nvim_list_chans()) do print(string.format(\"ID: %d, Mode: %s\", c.id, c.mode or \"none\")) end")' 2>&1
}

# Function to detach from a session (close all UI clients)
detach_session() {
    local session_name="$1"
    local socket_path
    socket_path=$(get_socket_path "$session_name")

    # Check if this is a remote session by parsing the session name
    local ssh_host
    ssh_host=$(parse_ssh_host "$session_name")
    local base_session_name
    base_session_name=$(parse_session_name "$session_name")

    if [[ -n "$ssh_host" ]]; then
        # For remote session, execute detach on remote host
        echo "Detaching from remote session '$base_session_name' on $ssh_host..."

        if ! establish_ssh_control_master "$ssh_host"; then
            echo -e "${RED}Failed to establish SSH connection${NC}"
            exit 1
        fi

        ssh_exec "$ssh_host" "nvim-screen -d '$base_session_name'"
        return $?
    fi

    if [[ ! -S "$socket_path" ]]; then
        echo -e "${RED}Error: Session '$session_name' not found.${NC}"
        exit 1
    fi

    # Get list of UI channel IDs to close (socket-based UIs only, not the stdio server)
    local channel_ids
    channel_ids=$(nvim --headless --server "$socket_path" --remote-expr "$(cat <<'LUA'
execute("lua for _, c in ipairs(vim.api.nvim_list_chans()) do
  if c.stream == \"socket\" and c.client and c.client.type == \"ui\" then
    print(c.id)
  end
end")
LUA
    )" 2>&1)

    if [[ -z "$channel_ids" ]]; then
        echo -e "${YELLOW}No UI clients to detach from session '$session_name'${NC}"
        return
    fi

    # Close each UI channel
    local closed=0
    while IFS= read -r chan_id; do
        if [[ -n "$chan_id" && "$chan_id" =~ ^[0-9]+$ ]]; then
            if nvim --headless --server "$socket_path" --remote-expr \
                "luaeval(\"vim.fn.chanclose($chan_id)\")" &>/dev/null; then
                closed=$((closed + 1))
            fi
        fi
    done <<< "$channel_ids"

    if [[ $closed -gt 0 ]]; then
        echo -e "${GREEN}Detached $closed UI client(s) from session '$session_name'${NC}"
    else
        echo -e "${RED}Failed to detach UI clients${NC}"
    fi
}

# Function to kill/terminate a session
kill_session() {
    local session_name="$1"
    local socket_path
    socket_path=$(get_socket_path "$session_name")

    # Check if this is a remote session by parsing the session name
    local ssh_host
    ssh_host=$(parse_ssh_host "$session_name")
    local base_session_name
    base_session_name=$(parse_session_name "$session_name")

    if [[ -n "$ssh_host" ]]; then
        # For remote session, execute kill on remote host
        echo "Terminating remote session '$base_session_name' on $ssh_host..."

        if ! establish_ssh_control_master "$ssh_host"; then
            echo -e "${RED}Failed to establish SSH connection${NC}"
            exit 1
        fi

        # Kill remote session
        if ssh_exec "$ssh_host" "nvim-screen -d '$base_session_name'"; then
            # Clean up local marker file
            rm -f "$socket_path"
            echo -e "${GREEN}Remote session terminated successfully${NC}"
            return 0
        else
            echo -e "${RED}Failed to terminate remote session${NC}"
            return 1
        fi
    fi

    if [[ ! -S "$socket_path" ]]; then
        echo -e "${RED}Error: Session '$session_name' not found.${NC}"
        exit 1
    fi

    echo "Terminating session: $session_name"

    # Try graceful quit via nvim remote-send
    if nvim --headless --server "$socket_path" --remote-send '<C-\><C-N>:qa<CR>' 2>/dev/null; then
        # Wait a bit for the session to close
        sleep 0.5

        # Check if the session closed successfully
        if [[ ! -S "$socket_path" ]]; then
            echo -e "${GREEN}Session terminated successfully${NC}"
            return 0
        elif ! check_socket_health "$socket_path"; then
            echo -e "${GREEN}Session terminated (socket cleanup pending)${NC}"
            # Clean up unresponsive socket
            rm -f "$socket_path"
            return 0
        else
            echo -e "${YELLOW}Warning: Session still running (may have unsaved changes)${NC}"
            return 1
        fi
    else
        echo -e "${RED}Failed to send quit command to session${NC}"
        # Try to clean up stale socket
        if ! check_socket_health "$socket_path"; then
            echo "Cleaning up unresponsive socket..."
            rm -f "$socket_path"
        fi
        return 1
    fi
}

# Function to clean up stale sockets
cleanup_stale_sockets() {
    local cleaned=0

    for item in "$SESSION_DIR"/${SOCKET_PREFIX}-*.sock; do
        if [[ ! -e "$item" ]]; then
            continue
        fi

        local full_session_name="${item##*/}"
        full_session_name="${full_session_name#${SOCKET_PREFIX}-}"
        full_session_name="${full_session_name%.sock}"

        # Parse to check if it's a remote session
        local ssh_host
        ssh_host=$(parse_ssh_host "$full_session_name")
        local base_session_name
        base_session_name=$(parse_session_name "$full_session_name")

        if [[ -S "$item" ]]; then
            # It's a real socket (local session)
            if ! check_socket_health "$item"; then
                echo "Removing stale socket: ${item##*/}"
                rm -f "$item"
                cleaned=$((cleaned + 1))
            fi
        elif [[ -f "$item" ]] && [[ -n "$ssh_host" ]]; then
            # It's a marker file for a remote session
            # Try to verify if remote session still exists
            if establish_ssh_control_master "$ssh_host" 2>/dev/null; then
                local remote_exists
                remote_exists=$(ssh_exec "$ssh_host" "[ -S \"\${XDG_RUNTIME_DIR:-/tmp}/nvim-sessions-\$USER/nvim-session-$base_session_name.sock\" ] && echo 'yes' || echo 'no'" 2>/dev/null)

                if [[ "$remote_exists" != "yes" ]]; then
                    echo "Removing orphaned remote session marker: ${item##*/}"
                    rm -f "$item"
                    cleaned=$((cleaned + 1))
                fi
            else
                echo "Warning: Cannot verify remote session '$base_session_name' on $ssh_host"
                echo "  Marker file exists but connection failed."
            fi
        elif [[ -f "$item" ]]; then
            # It's a marker file but not properly formatted - remove it
            echo "Removing invalid marker file: ${item##*/}"
            rm -f "$item"
            cleaned=$((cleaned + 1))
        fi
    done

    if [[ $cleaned -eq 0 ]]; then
        echo "No stale sessions found."
    else
        echo "Removed $cleaned stale item(s)."
    fi
}

# Function to show version
show_version() {
    echo "nvim-screen version $VERSION"
}

# Function to show usage
show_usage() {
    cat << EOF
Neovim Session Manager - GNU screen-like interface for Neovim

Usage: $(basename $0) [options] [command] [-- nvim_args...]

Options:
  -s <host>      Connect to remote host via SSH
  -S <name>      Start a new session with the specified name
  -ls, -list     List all active sessions (local and remote)
  -r [name]      Attach to session (if name not specified, attach to last or prompt)
  -d <name>      Detach/terminate the specified session
  -channels <name>  List channels for debugging (shows RPC connections)
  -wipe          Clean up stale/dead sessions
  -v, --version  Show version information
  -h, --help     Show this help message
  --             Pass all following arguments to nvim

Examples:
  $(basename $0) -S myproject                    # Start new session named 'myproject'
  $(basename $0) -S myproject -- file.txt        # Start session and open file.txt
  $(basename $0) -s user@host -S remote-proj     # Start session on remote host
  $(basename $0) -s user@host -ls                # List sessions on remote host
  $(basename $0) -- -O file1.txt file2.txt       # Start session with vertical split
  $(basename $0) -S test -- -c 'set number'      # Start session with nvim command

Inside Neovim:
  :detach                  Detach from session (keeps it running)
  Ctrl-\\ Ctrl-N           Alternative way to detach

Session sockets are stored in: $SESSION_DIR
EOF
}

# Main script logic
main() {
    local action="start"
    local session_name=""
    local ssh_host=""
    local nvim_args=()

    # Parse command line arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -s)
                shift
                if [[ $# -gt 0 ]]; then
                    ssh_host="$1"
                    shift
                else
                    echo -e "${RED}Error: -s requires an SSH host${NC}"
                    exit 1
                fi
                ;;
            -S)
                action="start"
                shift
                if [[ $# -gt 0 ]]; then
                    session_name="$1"
                    shift
                else
                    echo -e "${RED}Error: -S requires a session name${NC}"
                    exit 1
                fi
                ;;
            -ls|-list)
                action="list"
                shift
                ;;
            -r|-x)
                action="attach"
                shift
                if [[ $# -gt 0 ]] && [[ ! "$1" =~ ^- ]]; then
                    session_name="$1"
                    shift
                fi
                ;;
            -d|-D)
                action="detach"
                shift
                if [[ $# -gt 0 ]]; then
                    session_name="$1"
                    shift
                else
                    echo -e "${RED}Error: -d requires a session name${NC}"
                    exit 1
                fi
                ;;
            -channels)
                action="channels"
                shift
                if [[ $# -gt 0 ]]; then
                    session_name="$1"
                    shift
                else
                    echo -e "${RED}Error: -channels requires a session name${NC}"
                    exit 1
                fi
                ;;
            -wipe)
                action="wipe"
                shift
                ;;
            -v|--version)
                show_version
                exit 0
                ;;
            -h|--help)
                show_usage
                exit 0
                ;;
            --)
                # Everything after -- is passed to nvim
                shift
                nvim_args=("$@")
                break
                ;;
            *)
                echo -e "${RED}Unknown option: $1${NC}"
                echo
                show_usage
                exit 1
                ;;
        esac
    done

    # Handle SSH connection if specified
    if [[ -n "$ssh_host" ]]; then
        echo "Establishing SSH connection to $ssh_host..."
        if ! establish_ssh_control_master "$ssh_host"; then
            exit 1
        fi

        # Check if nvim-screen is installed on remote
        if ! check_remote_nvim_screen "$ssh_host"; then
            echo -e "${RED}Error: nvim-screen is not installed on $ssh_host${NC}"
            echo
            echo "Please install nvim-screen on the remote host first:"
            echo "  ssh $ssh_host 'curl -fsSL https://raw.githubusercontent.com/tijoseymathew/nvim-screen/main/install.sh | bash'"
            echo
            close_ssh_control_master "$ssh_host"
            exit 1
        fi
    fi

    # Execute action
    case "$action" in
        list)
            list_sessions "$ssh_host"
            ;;
        start)
            if [[ -z "$session_name" ]]; then
                session_name=$(generate_session_name)
            fi
            start_session "$session_name" "$ssh_host" "${nvim_args[@]}"
            ;;
        attach)
            if [[ -z "$session_name" ]]; then
                # Find available sessions (both local sockets and remote marker files)
                local available_sessions=()

                # Look for all .sock files (both real sockets and marker files)
                for item in "$SESSION_DIR"/${SOCKET_PREFIX}-*.sock; do
                    if [[ -e "$item" ]]; then
                        local name="${item##*/}"
                        name="${name#${SOCKET_PREFIX}-}"
                        name="${name%.sock}"
                        available_sessions+=("$name")
                    fi
                done

                if [[ ${#available_sessions[@]} -eq 0 ]]; then
                    echo -e "${RED}No active sessions found.${NC}"
                    exit 1
                elif [[ ${#available_sessions[@]} -eq 1 ]]; then
                    session_name="${available_sessions[0]}"
                else
                    echo "Multiple sessions available:"
                    for i in "${!available_sessions[@]}"; do
                        echo "  $((i+1)). ${available_sessions[$i]}"
                    done
                    echo
                    read -r -p "Select session number (or name): " selection
                    if [[ "$selection" =~ ^[0-9]+$ ]] && [[ $selection -le ${#available_sessions[@]} ]]; then
                        session_name="${available_sessions[$((selection-1))]}"
                    else
                        session_name="$selection"
                    fi
                fi
            fi
            attach_session "$session_name"
            ;;
        detach)
            detach_session "$session_name"
            ;;
        channels)
            list_channels "$session_name"
            ;;
        wipe)
            cleanup_stale_sockets
            echo "Stale sessions cleaned up."
            ;;
    esac
}

main "$@"
