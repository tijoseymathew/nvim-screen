#!/usr/bin/env bash

# Neovim Session Manager - mimics GNU screen interface
# Usage similar to screen: nvim-session [-S name] [-ls] [-r [name]] [-d name]

set -euo pipefail

# Configuration
VERSION="0.1.0"
SESSION_DIR="${XDG_RUNTIME_DIR:-/tmp}/nvim-sessions-${USER}"
SOCKET_PREFIX="nvim-session"
CONFIG_DIR="${XDG_CONFIG_HOME:-$HOME/.config}/nvim-screen"

# Colors for output
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
RED='\033[0;31m'
NC='\033[0m' # No Color

# Ensure session directory exists
mkdir -p "$SESSION_DIR"

# Function to get the init script to use
get_init_script() {
    local init_script="$CONFIG_DIR/init.lua"
    if [[ -f "$init_script" ]]; then
        echo "$init_script"
    else
        echo ""
    fi
}

# Function to generate a session name
generate_session_name() {
    local base_name="${PWD##*/}"
    local counter=0
    local session_name="$base_name"

    while [[ -S "$SESSION_DIR/${SOCKET_PREFIX}-${session_name}.sock" ]]; do
        counter=$((counter + 1))
        session_name="${base_name}-${counter}"
    done

    echo "$session_name"
}

# Function to get socket path for a session
get_socket_path() {
    local session_name="$1"
    echo "$SESSION_DIR/${SOCKET_PREFIX}-${session_name}.sock"
}

# Function to check if a socket is healthy
check_socket_health() {
    local socket_path="$1"
    nvim --headless --server "$socket_path" --remote-expr '1+1' &>/dev/null
    return $?
}

# Function to list active sessions
list_sessions() {
    local sessions=()
    local has_sessions=false

    echo "Active Neovim sessions:"
    echo

    for socket in "$SESSION_DIR"/${SOCKET_PREFIX}-*.sock; do
        if [[ -S "$socket" ]]; then
            has_sessions=true
            local session_name="${socket##*/}"
            session_name="${session_name#${SOCKET_PREFIX}-}"
            session_name="${session_name%.sock}"

            # Check if session is healthy
            if check_socket_health "$socket"; then
                echo -e "  ${GREEN}●${NC} $session_name (healthy)"
            else
                echo -e "  ${YELLOW}○${NC} $session_name (unresponsive)"
            fi
        fi
    done

    if [[ "$has_sessions" == false ]]; then
        echo "  No active sessions"
    fi
    echo
}

# Function to start a new session
start_session() {
    local session_name="$1"
    local socket_path
    socket_path=$(get_socket_path "$session_name")

    if [[ -S "$socket_path" ]]; then
        echo -e "${YELLOW}Session '$session_name' already exists.${NC}"
        echo "Use '$0 -r $session_name' to attach to it."
        exit 1
    fi

    # Get the init script to source
    local init_script
    init_script=$(get_init_script)

    # Start nvim with server listening on socket
    if [[ -n "$init_script" ]]; then
        # Source the init script after nvim's standard initialization
        exec nvim --listen "$socket_path" -S "$init_script"
    else
        # No init script, just start normally
        exec nvim --listen "$socket_path"
    fi
}

# Function to attach to existing session
attach_session() {
    local session_name="$1"
    local socket_path
    socket_path=$(get_socket_path "$session_name")

    if [[ ! -S "$socket_path" ]]; then
        echo -e "${RED}Error: Session '$session_name' not found.${NC}"
        echo
        list_sessions
        exit 1
    fi

    # Attach to existing nvim server
    exec nvim --server "$socket_path" --remote-ui
}

# Function to list channels for debugging
list_channels() {
    local session_name="$1"
    local socket_path
    socket_path=$(get_socket_path "$session_name")

    if [[ ! -S "$socket_path" ]]; then
        echo -e "${RED}Error: Session '$session_name' not found.${NC}"
        exit 1
    fi

    echo "Listing channels for session: $session_name"
    echo

    # Get channel count
    echo "Number of channels:"
    nvim --headless --server "$socket_path" --remote-expr \
        'luaeval("#vim.api.nvim_list_chans()")' 2>&1

    echo
    echo "Channel details (JSON format):"
    nvim --headless --server "$socket_path" --remote-expr \
        'luaeval("vim.json.encode(vim.api.nvim_list_chans())")' 2>&1 | jq '.' 2>/dev/null || cat

    echo
    echo "Channel summary:"
    nvim --headless --server "$socket_path" --remote-expr \
        'execute("lua for _, c in ipairs(vim.api.nvim_list_chans()) do print(string.format(\"ID: %d, Mode: %s\", c.id, c.mode or \"none\")) end")' 2>&1
}

# Function to detach from a session (close all UI clients)
detach_session() {
    local session_name="$1"
    local socket_path
    socket_path=$(get_socket_path "$session_name")

    if [[ ! -S "$socket_path" ]]; then
        echo -e "${RED}Error: Session '$session_name' not found.${NC}"
        exit 1
    fi

    # Get list of UI channel IDs to close (socket-based UIs only, not the stdio server)
    local channel_ids
    channel_ids=$(nvim --headless --server "$socket_path" --remote-expr "$(cat <<'LUA'
execute("lua for _, c in ipairs(vim.api.nvim_list_chans()) do
  if c.stream == \"socket\" and c.client and c.client.type == \"ui\" then
    print(c.id)
  end
end")
LUA
    )" 2>&1)

    if [[ -z "$channel_ids" ]]; then
        echo -e "${YELLOW}No UI clients to detach from session '$session_name'${NC}"
        return
    fi

    # Close each UI channel
    local closed=0
    while IFS= read -r chan_id; do
        if [[ -n "$chan_id" && "$chan_id" =~ ^[0-9]+$ ]]; then
            if nvim --headless --server "$socket_path" --remote-expr \
                "luaeval(\"vim.fn.chanclose($chan_id)\")" &>/dev/null; then
                closed=$((closed + 1))
            fi
        fi
    done <<< "$channel_ids"

    if [[ $closed -gt 0 ]]; then
        echo -e "${GREEN}Detached $closed UI client(s) from session '$session_name'${NC}"
    else
        echo -e "${RED}Failed to detach UI clients${NC}"
    fi
}

# Function to kill/terminate a session
kill_session() {
    local session_name="$1"
    local socket_path
    socket_path=$(get_socket_path "$session_name")

    if [[ ! -S "$socket_path" ]]; then
        echo -e "${RED}Error: Session '$session_name' not found.${NC}"
        exit 1
    fi

    echo "Terminating session: $session_name"

    # Try graceful quit via nvim remote-send
    if nvim --headless --server "$socket_path" --remote-send '<C-\><C-N>:qa<CR>' 2>/dev/null; then
        # Wait a bit for the session to close
        sleep 0.5

        # Check if the session closed successfully
        if [[ ! -S "$socket_path" ]]; then
            echo -e "${GREEN}Session terminated successfully${NC}"
            return 0
        elif ! check_socket_health "$socket_path"; then
            echo -e "${GREEN}Session terminated (socket cleanup pending)${NC}"
            # Clean up unresponsive socket
            rm -f "$socket_path"
            return 0
        else
            echo -e "${YELLOW}Warning: Session still running (may have unsaved changes)${NC}"
            return 1
        fi
    else
        echo -e "${RED}Failed to send quit command to session${NC}"
        # Try to clean up stale socket
        if ! check_socket_health "$socket_path"; then
            echo "Cleaning up unresponsive socket..."
            rm -f "$socket_path"
        fi
        return 1
    fi
}

# Function to clean up stale sockets
cleanup_stale_sockets() {
    local cleaned=0
    for socket in "$SESSION_DIR"/${SOCKET_PREFIX}-*.sock; do
        if [[ -S "$socket" ]]; then
            # Check if socket is healthy
            if ! check_socket_health "$socket"; then
                echo "Removing stale socket: ${socket##*/}"
                rm -f "$socket"
                cleaned=$((cleaned + 1))
            fi
        fi
    done

    if [[ $cleaned -eq 0 ]]; then
        echo "No stale sockets found."
    else
        echo "Removed $cleaned stale socket(s)."
    fi
}

# Function to show version
show_version() {
    echo "nvim-screen version $VERSION"
}

# Function to show usage
show_usage() {
    cat << EOF
Neovim Session Manager - GNU screen-like interface for Neovim

Usage: $(basename $0) [options] [command]

Options:
  -S <name>      Start a new session with the specified name
  -ls, -list     List all active sessions
  -r [name]      Attach to session (if name not specified, attach to last or prompt)
  -d <name>      Detach/terminate the specified session
  -channels <name>  List channels for debugging (shows RPC connections)
  -wipe          Clean up stale/dead sessions
  -v, --version  Show version information
  -h, --help     Show this help message

Inside Neovim:
  :detach                  Detach from session (keeps it running)
  Ctrl-\\ Ctrl-N           Alternative way to detach

Session sockets are stored in: $SESSION_DIR
EOF
}

# Main script logic
main() {
    local action="start"
    local session_name=""

    # Parse command line arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -S)
                action="start"
                shift
                if [[ $# -gt 0 ]]; then
                    session_name="$1"
                    shift
                else
                    echo -e "${RED}Error: -S requires a session name${NC}"
                    exit 1
                fi
                ;;
            -ls|-list)
                action="list"
                shift
                ;;
            -r|-x)
                action="attach"
                shift
                if [[ $# -gt 0 ]] && [[ ! "$1" =~ ^- ]]; then
                    session_name="$1"
                    shift
                fi
                ;;
            -d|-D)
                action="detach"
                shift
                if [[ $# -gt 0 ]]; then
                    session_name="$1"
                    shift
                else
                    echo -e "${RED}Error: -d requires a session name${NC}"
                    exit 1
                fi
                ;;
            -channels)
                action="channels"
                shift
                if [[ $# -gt 0 ]]; then
                    session_name="$1"
                    shift
                else
                    echo -e "${RED}Error: -channels requires a session name${NC}"
                    exit 1
                fi
                ;;
            -wipe)
                action="wipe"
                shift
                ;;
            -v|--version)
                show_version
                exit 0
                ;;
            -h|--help)
                show_usage
                exit 0
                ;;
            *)
                echo -e "${RED}Unknown option: $1${NC}"
                echo
                show_usage
                exit 1
                ;;
        esac
    done

    # Execute action
    case "$action" in
        list)
            list_sessions
            ;;
        start)
            if [[ -z "$session_name" ]]; then
                session_name=$(generate_session_name)
            fi
            start_session "$session_name"
            ;;
        attach)
            if [[ -z "$session_name" ]]; then
                # Find available sessions
                local available_sessions=()
                for socket in "$SESSION_DIR"/${SOCKET_PREFIX}-*.sock; do
                    if [[ -S "$socket" ]]; then
                        local name="${socket##*/}"
                        name="${name#${SOCKET_PREFIX}-}"
                        name="${name%.sock}"
                        available_sessions+=("$name")
                    fi
                done

                if [[ ${#available_sessions[@]} -eq 0 ]]; then
                    echo -e "${RED}No active sessions found.${NC}"
                    exit 1
                elif [[ ${#available_sessions[@]} -eq 1 ]]; then
                    session_name="${available_sessions[0]}"
                else
                    echo "Multiple sessions available:"
                    for i in "${!available_sessions[@]}"; do
                        echo "  $((i+1)). ${available_sessions[$i]}"
                    done
                    echo
                    read -r -p "Select session number (or name): " selection
                    if [[ "$selection" =~ ^[0-9]+$ ]] && [[ $selection -le ${#available_sessions[@]} ]]; then
                        session_name="${available_sessions[$((selection-1))]}"
                    else
                        session_name="$selection"
                    fi
                fi
            fi
            attach_session "$session_name"
            ;;
        detach)
            detach_session "$session_name"
            ;;
        channels)
            list_channels "$session_name"
            ;;
        wipe)
            cleanup_stale_sockets
            echo "Stale sessions cleaned up."
            ;;
    esac
}

main "$@"
